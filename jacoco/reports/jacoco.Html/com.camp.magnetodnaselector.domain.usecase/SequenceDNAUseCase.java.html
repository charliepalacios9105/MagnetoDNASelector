<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SequenceDNAUseCase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MagnetoDNASelector</a> &gt; <a href="index.source.html" class="el_package">com.camp.magnetodnaselector.domain.usecase</a> &gt; <span class="el_source">SequenceDNAUseCase.java</span></div><h1>SequenceDNAUseCase.java</h1><pre class="source lang-java linenums">package com.camp.magnetodnaselector.domain.usecase;

import com.camp.magnetodnaselector.domain.exception.InvalidDNAException;
import com.camp.magnetodnaselector.domain.model.SequenceDNAModel;
import com.camp.magnetodnaselector.domain.model.StatModel;
import com.camp.magnetodnaselector.domain.model.gateway.SequenceDNARepository;
import com.camp.magnetodnaselector.domain.model.gateway.StatRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
@RequiredArgsConstructor
public class SequenceDNAUseCase {

    /**
     * Numero minimo de secuencias que debe tener la cadena de ADN para determinar si se es un mutante
     */
    private static final int MIN_NUMBER_OF_SEQ = 2;

    /**
     * Cantidad de caracteres repetidos que se deben tener las secuencias a buscar
     */
    private static final int SEQUENCE_SIZE = 4;

    /**
     * Patron de conteo que determina si en una cadena de texto existen una cantidad determinada de caracteres repetidos.
     * En este caso esta cantidad esta dada por SEQUENCE_SIZE.
     * La expresion regular se descompone asi:
     * (\w): Determina cualquier caracter alfanumerico
     * \1: Determina que se espera repeticion de el patron encontrado en la posicion anterior
     * { (SEQUENCE_SIZE - 1) }: Determina la cantidad exacta de veces que se evalua el patron anterior,
     * es SEQUENCE_SIZE - 1 debido a que primer patron se evalua con el \1.
     */
<span class="fc" id="L38">    private static final Pattern COUNT_SEQUENCE_PATTERN = Pattern.compile(&quot;(\\w)\\1{&quot; + (SEQUENCE_SIZE - 1) + &quot;}+&quot;);</span>

    /**
     * Patron de conteo que determina si en la cadena existen caracteres diferentes a los contenidos en la
     * expreson y separados por el operador |
     */
<span class="fc" id="L44">    private static final Pattern VALID_CHAR_PATTERN = Pattern.compile(&quot;[ATCG]+&quot;);</span>

    private final SequenceDNARepository sequenceDNARepository;
    private final StatRepository statRepository;

    public boolean isMutant(SequenceDNAModel sequenceDNAModel) throws InvalidDNAException {
<span class="fc" id="L50">        Boolean res = sequenceDNARepository.isMutantSavedDNA(sequenceDNAModel.getDna());</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">        if (res == null) {</span>
<span class="fc" id="L52">            AtomicInteger count = new AtomicInteger(0);</span>
<span class="fc" id="L53">            String[] dna = sequenceDNAModel.getDna();</span>
<span class="fc" id="L54">            int size = dna.length;</span>
<span class="fc" id="L55">            validDNASequence(count, dna, size);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">            if (count.intValue() &lt; MIN_NUMBER_OF_SEQ) {</span>
<span class="fc" id="L57">                generateAndEvalSubsequence(dna, count, size);</span>
            }
<span class="fc bfc" id="L59" title="All 2 branches covered.">            res = count.intValue() &gt;= MIN_NUMBER_OF_SEQ;</span>
<span class="fc" id="L60">            sequenceDNARepository.saveDNA(sequenceDNAModel, res);</span>
        }
<span class="fc" id="L62">        return res;</span>
    }

    private void validDNASequence(AtomicInteger count, String[] dna, int size) throws InvalidDNAException {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (size &lt; SEQUENCE_SIZE) {</span>
<span class="fc" id="L67">            throw new InvalidDNAException(&quot;The length of the DNA string is less than the minimum allowed&quot;);</span>
        }
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (String seq : dna) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (seq.length() != size) {//No es valida la secuencia si el tamanio de alguno de sus elementos es direfente al taminio del vector</span>
<span class="fc" id="L71">                throw new InvalidDNAException(&quot;The length of an individual string is different than the DNA string&quot;);</span>
            }
<span class="fc" id="L73">            Matcher validateMatcher = VALID_CHAR_PATTERN.matcher(seq);//No es valida la secuencia si contiene caracteres diferentes a los establecidos en el patron de validacion</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">            if (validateMatcher.matches()) {</span>
<span class="fc" id="L75">                evalSequence(seq, count); // Se hace una primera evaluacion de las cadenas que componen el vector, siendo esta la evalucion del las horizontales</span>
            } else {
<span class="fc" id="L77">                throw new InvalidDNAException(&quot;The individual string has illegal characters&quot;);</span>
            }
        }
<span class="fc" id="L80">    }</span>

    private void generateAndEvalSubsequence(String[] dna, AtomicInteger count, int size) {
<span class="fc" id="L83">        StringBuilder topLeftDiagonalSeq = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L84">        StringBuilder lowerRightDiagonalSeq = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L85">        StringBuilder lowerLeftDiagonalSeq = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L86">        StringBuilder topRightDiagonalSeq = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L87">        StringBuilder verticalSeq = new StringBuilder(&quot;&quot;);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="fc bfc" id="L90" title="All 4 branches covered.">                if ((i + SEQUENCE_SIZE) &lt;= size &amp;&amp; (j &lt; (size - i))) { //Validacion para evitar las cadenas diagonales de menor logitud al tamanio de la secuencia</span>
<span class="fc" id="L91">                    lowerLeftDiagonalSeq.append(dna[i + j].charAt((size - 1) - j));</span>
<span class="fc" id="L92">                    topRightDiagonalSeq.append(dna[j].charAt(j + i));</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                    if (i &gt; 0) {//Para que no se repitan las diagonales principales</span>
<span class="fc" id="L94">                        topLeftDiagonalSeq.append(dna[j].charAt((size - 1) - j - i));</span>
<span class="fc" id="L95">                        lowerRightDiagonalSeq.append(dna[j + i].charAt(j));</span>
                    }
                }
<span class="fc" id="L98">                verticalSeq.append(dna[j].charAt(i));</span>
            }
<span class="fc" id="L100">            validSequenceList(count, verticalSeq, topLeftDiagonalSeq, lowerLeftDiagonalSeq, topRightDiagonalSeq, lowerRightDiagonalSeq);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (count.intValue() &gt;= MIN_NUMBER_OF_SEQ) {</span>
<span class="fc" id="L102">                return;</span>
            }
        }
<span class="fc" id="L105">    }</span>

    public void validSequenceList(AtomicInteger count, StringBuilder... sequences) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (StringBuilder sequence : sequences) {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (sequence.length() &gt; 0) {</span>
<span class="fc" id="L110">                evalSequence(sequence.toString(), count);</span>
<span class="fc" id="L111">                sequence.setLength(0);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                if (count.intValue() &gt;= MIN_NUMBER_OF_SEQ) {</span>
<span class="fc" id="L113">                    return;</span>
                }
            }
        }
<span class="fc" id="L117">    }</span>

    private void evalSequence(String seq, AtomicInteger count) {
<span class="fc" id="L120">        Matcher m = COUNT_SEQUENCE_PATTERN.matcher(seq);</span>
<span class="fc" id="L121">        count.addAndGet((int) m.results().count());</span>
<span class="fc" id="L122">    }</span>

    public StatModel getStat() {
<span class="fc" id="L125">        return statRepository.getStat();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>